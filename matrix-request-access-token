#!/usr/bin/env bash
[[ $DEBUG ]] && set -x
set -o errexit
LANG=C


help_doc() {
	{ read -r -d '' || :; [[ $REPLY == '|'* ]] && REPLY=${REPLY:1}; printf '%s' "${REPLY//$'\n|'/$'\n'}"; } <<-'HelpDoc'
		|matrix-request-access-token [ARGUEMENT...] [--] [HOMESERVER]

		|A curl wrapper for requesting an access token from a matrix homeserver.

		|DEPENDENCIES
		|	curl

		|ARGUEMENT
		|	-u|--user USER
		|	-I|--device-id ID                       Optional ID of known device
		|	-n|--initial-device-display-name NAME   Optional display NAME for new device
		|	-r|--refresh-token true || false		Optional client support for refresh tokens
		|	-P|--password-file PASSWORD_FILE		See: PASSWORD_FILE
		|	-U|--user-file USER_FILE                See: USER_FILE
		|	--dry-run                               Do everything except send the request
		|	--debug                                 Output debugging information
		|	-h|--help                               Print help doc
		|	HOMESERVER                              Homeserver base url

		|PASSWORD_FILE
		|	Path to a file containing a password on the first line. Additional lines are ignored.
		|	If the path is a hyphen (-), path becomes stdin.

		|USER_FILE
		|	Path to a file containing VALUE_PAIRs as an alternative to using ARGUEMENTs, ex:
		|		VAR_NAME=VALUE
		|		
		|	If the path is a hyphen (-), path becomes stdin.
		|
		|	ACCEPTED VAR_NAMEs:
		|		homeserver, user, password, device_id, refresh_token, initial_device_display_name
		|
		|	- Lines not containing a VALUE_PAIR with an ACCEPTED VAR_NAME are ignored as comments.
		|	- Each VALUE_PAIR must be on its own line ending in a newline.
		|	- VAR_NAME is every character after tab/space indenting until the first equals (=).
		|	- VALUE is every character after the first equals (=) until the first newline (\n).
		|	- VAR_NAME and VALUE are read as raw text with no escaping or special rules.

		|ENVIRONMENT
		|	MATRIX__HOMESERVER                    Matrix homeserver url, ex: https://myhomeserver.org
		|	MATRIX__USER                          Account username, not including @...
		|	MATRIX__DEVICE_ID                     Optional ID of known device
		|	MATRIX__REFRESH_TOKEN                 true || false, optional client support for refresh tokens
		|	MATRIX__INITIAL_DEVICE_DISPLAY_NAME   Optional display name for new device

		|VALUE PRIORITY
		|	ARGUEMENT value > PASSWORD_FILE value > USER_FILE value > ENVIRONMENT value

		|EXAMPLES
		|	# User interactive prompts to enter missing information that's required
		|	matrix-request-access-token
		|
		|	# Headless request using ARGUEMENTS
		|	matrix-request-access-token -u myuser -P <(printf '%s' 'mypass') 'https://myhomeserver.org'
		|
		|	# Create a USER_FILE
		|	>'/path/to/myuser'
		|	chmod 600 -- '/path/to/myuser'
		|	cat <<-'EOF' > '/path/to/myuser'
		|		initial_device_display_name=My Device
		|		refresh_token=true
		|		device_id=12345
		|		user=myuser
		|		password=m\y pa#ss
		|		homeserver=https://myhomeserver.org
		|	EOF
		|
		|	# Headless request using a USER_FILE
		| 	matrix-request-access-token -U '/path/to/myuser'
	HelpDoc
	[[ $1 ]] && exit "$1"
}



print_stderr() {
	if [[ $1 == '0' ]]; then
		[[ $2 ]] && printf "$2" "${@:3}" 1>&2 || :
	else
		[[ $2 ]] && printf '%s'"$2" "ERROR: ${0##*/}, " "${@:3}" 1>&2 || :
		exit "$1"
	fi
}



# Check dependencies
type curl 1>/dev/null



user=
device_id=
initial_device_display_name=
homeserver=
homeservers=()
user_file_path=
password_file_path=
debug=
dry_run=
declare -A user=(
	['homeserver']=
	['user']=
	['password']=
	['device_id']=
	['refresh_token']=
	['initial_device_display_name']=
)

while [[ $1 ]]; do
	case $1 in
		'--user'|'-u')
			shift; user['user']=$1 ;;
		'--device-id'|'-I')
			shift; user['device_id']=$1 ;;
		'--refresh-token'|'-r')
			shift; user['refresh_token']=$1 ;;
		'--initial-device-display-name'|'-n')
			shift; user['initial_device_display_name']=$1 ;;
		'--password-file'|'-P')
			shift; password_file_path=$1 ;;
		'--user-file'|'-U')
			shift; user_file_path=$1 ;;
		'--dry-run')
			dry_run=1 ;;
		'--debug')
			debug=1 ;;
		'--help'|'-h')
			help_doc 0 ;;
		'--')
			shift; break ;;
		'-'*)
			print_stderr 1 '%s %q\n' 'unrecognized parameter:' "$1" ;;
		*)
			homeservers+=("$1") ;;
	esac
	shift
done
homeservers+=("$@")



if [[ ${#homeservers[@]} != '0' ]]; then
	[[ ${#homeservers[@]} != '1' ]] && print_stderr 1 '%s\n' 'more than one base url parameter given'
	user['homeserver']=${homeservers[0]}
fi
unset homeservers



if [[ $password_file_path && ! ${user['password']} ]]; then
	[[ $password_file_path == '-' ]] && password_file_path='/proc/self/fd/0'
	{ read -r user['password'] || :; } < "$password_file_path"
fi



# Define function for loading auth files 
load_auth_file() {
	# input vars: user, user_file_path
	local no_clobber=$1 file_str var_name


	[[ $user_file_path == '-' ]] && user_file_path='/proc/self/fd/0'


	while IFS='=' read -r prop val; do
		[[ $val ]] || continue
		prop=${prop#"${prop%%[![:space:]]*}"}
		[[ $prop ]] || continue

		# Only accept value pairs the script is looking for
		[[ user["$prop"] ]] || continue

		[[ $no_clobber && ${user["$prop"]} ]] && continue
		user["$prop"]=$val
	done < "$user_file_path"


	# debug: print contents of gathered user data
	if [[ $debug ]]; then
		printf '%s\n' "Read values from ${user_file_path@Q}:" 1>&2
		for prop in "${!user[@]}"; do
			[[ $prop ]] || continue
			printf '%s\n' "  $prop=${user["$prop"]}" 1>&2
		done
		printf '\n' 1>&2
	fi
}


# Load auth file if provided, without clobbering
[[ $user_file_path ]] && load_auth_file 1



# Load env variables if provided, without clobbering
: ${user['homeserver']:=$MATRIX__HOMESERVER}
: ${user['user']:=$MATRIX__USER}
: ${user['device_id']:=$MATRIX__DEVICE_ID}
: ${user['refresh_token']:=$MATRIX__REFRESH_TOKEN}
: ${user['initial_device_display_name']:=$MATRIX__INITIAL_DEVICE_DISPLAY_NAME}



# Define function for setting the value of a parent variable with an interactive prompt
prompt() {
	local read_prompt=$1 read_var=$2 visibility=$3 read_params=()

	[[ $visibility == 'show' || $visibility == 'hide' ]] || print_stderr 1 '%s\n' "bad use of prompt() params: ${*@Q}"

	# stdin must be connected to a terminal
	[[ -t 0 ]] || return 1

	[[ $visibility == 'hide' ]] && read_params+=('-s')
	read_params+=('-r' '-p' "${read_prompt} " "$read_var")

	IFS= read "${read_params[@]}" < /dev/tty

	[[ $visibility == 'hide' ]] && printf '\n' 1>&2
	[[ ! ${!read_var} ]] && return 4
	return 0
}



# Prompt for values mandatory for a successful request
[[ ${user['homeserver']} ]] || prompt 'Enter base url (ex: https://matrix-client.matrix.org):' "user['homeserver']" 'show' || print_stderr 1 '%s\n' 'no homeserver provided'
[[ ${user['user']} ]] || prompt 'Enter username (ex: myuser):' "user['user']" 'show' || print_stderr 1 '%s\n' 'no user provided'
[[ ${user['password']} ]] || prompt 'Enter password:' "user['password']" 'hide' || print_stderr 1 '%s\n' 'no password provided'



# debug: print contents of gathered user data
if [[ $debug ]]; then
	printf '%s\n' "Using values:" 1>&2
	for prop in "${!user[@]}"; do
		[[ $prop ]] || continue
		printf '%s\n' "  $prop=${user["$prop"]}" 1>&2
	done
	printf '\n' 1>&2
fi



# Define JSON for request
json_encode() {
	local -n 'json_encode__str='"$1"
	json_encode__str=${json_encode__str//\\/\\\\}
	json_encode__str=${json_encode__str//\"/\\\"} #"
	json_encode__str=${json_encode__str//$'\n'/\\n}
	json_encode__str=${json_encode__str//$'\t'/\\t}
}
json_encode user['user']
json_encode user['password']



inline_json__device_id=
if [[ ${user['device_id']} ]]; then
	json_encode user['device_id']
	inline_json__device_id="\"device_id\": \"${user['device_id']}\","
fi


inline_json__refresh_token=
if [[ ${user['refresh_token']} ]]; then
	[[ ${user['refresh_token']} == 'true' || ${user['refresh_token']} == 'false' ]] || print_stderr 1 '%s %q\n' 'refresh_token must be true or false, illegal value:' "${user['refresh_token']}"
	inline_json__refresh_token="\"refresh_token\": \"${user['refresh_token']}\","
fi


inline_json__initial_device_display_name=
if [[ ${user['initial_device_display_name']} ]]; then
	json_encode user['initial_device_display_name']
	inline_json__initial_device_display_name="\"initial_device_display_name\": \"${user['initial_device_display_name']}\","
fi



{ read -r -d '' req_json || :; } <<-EOF
	{
		"identifier": {
			"type": "m.id.user",
			${inline_json__device_id}
			"user": "${user['user']}"
		},
		${inline_json__refresh_token}
		${inline_json__initial_device_display_name}
		"password": "${user['password']}",
		"type": "m.login.password"
	}
EOF
req_json=${req_json//,$'\n'/', '}
req_json=${req_json//$'\n'}



# debug: print JSON for request
if [[ $debug ]]; then
	printf '%s\n' "req_json=${req_json}"

	curl() {
		printf '%s ' 'curl' "${@@Q}" 1>&2; printf '\n---\n' 1>&2
		[[ $dry_run ]] || curl "$@"
	}
elif [[ $dry_run ]]; then
	exit 0
fi



# Send request
curl \
	-X POST \
	-H 'Content-Type: application/json' \
	-d @<(printf '%s' "$req_json") \
	-- \
	"${user['homeserver']}/_matrix/client/v3/login"



[[ -t 0 ]] && printf '\n' 1>&2
exit 0



